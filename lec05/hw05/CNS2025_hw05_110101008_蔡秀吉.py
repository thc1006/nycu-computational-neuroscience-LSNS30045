# -*- coding: utf-8 -*-
"""CNS2025_hw05_110263008_蔡秀吉.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-aMGC-tRA9ZUHuGux9cJUd5XnDrYLQuD
"""

# @title
import os, math
import numpy as np
import matplotlib.pyplot as plt

def _rng(seed=None): return np.random.default_rng(seed)
def _ensure_dir(p): os.makedirs(p, exist_ok=True)

DT        = 1e-3
WIN_STA   = (-0.5, 0.1)
SIGMA_GAU = 0.05
DUR_EX1   = 104.0
DUR_EX2   = 10.0
N_RASTER  = 100
OUTDIR    = "cns2025_hw05_outputs"; _ensure_dir(OUTDIR)

def _exec_ipynb_in_globals(path="code05.ipynb"):
    try:
        import nbformat
        with open(path, "r", encoding="utf-8") as f:
            nb = nbformat.read(f, as_version=4)
        g = globals()
        for c in nb.cells:
            if c.cell_type == "code":
                try: exec(c.source, g)
                except Exception: pass
        return True
    except Exception:
        return False

for candidate in ["code05.ipynb", "/content/code05.ipynb", "/content/drive/MyDrive/code05.ipynb"]:
    if os.path.exists(candidate):
        _exec_ipynb_in_globals(candidate)
        break

def simulate_lif_model(duration_s=1.0, dt=DT, input_current=None, seed=0,
                       V_rest=-65.0, V_reset=-65.0, V_th=-52.0,
                       tau_m=0.020, R_m=10.0, t_ref=0.005, wn_std=2.5):
    rng = _rng(seed)
    T = int(round(duration_s/dt))
    times = np.arange(T)*dt
    if input_current is None:
        input_current = rng.normal(0.0, wn_std, size=T)
    V = V_rest; ref = 0.0; spk=[]
    for i in range(T):
        if ref>0: ref-=dt; V=V_reset
        else:
            V += (-(V - V_rest) + R_m*input_current[i])*(dt/tau_m)
            if V>=V_th:
                spk.append(i*dt); V=V_reset; ref=t_ref
    return np.array(spk,float), np.asarray(input_current,float), times, dt

def make_colored_stimulus(T, dt=DT, seed=42, tau=0.050, std=1.0):
    rng=_rng(seed); a=np.exp(-dt/tau); w=rng.normal(0.0,std,size=T)
    x=np.zeros(T,float)
    for i in range(1,T): x[i]=a*x[i-1]+np.sqrt(1-a*a)*w[i]
    return x

def gaussian_kernel_continuous(sigma, dt):
    half=int(np.ceil(5*sigma/dt)); kx=np.arange(-half,half+1)*dt
    kern=np.exp(-(kx/sigma)**2/2)/(np.sqrt(2*np.pi)*sigma)
    kern/= (kern.sum()*dt)    # area=1
    return kern, kx

def spikes_to_rate_gaussian(spike_times, times, sigma=SIGMA_GAU):
    dt = times[1]-times[0]; T=len(times)
    x=np.zeros(T,float); idx=np.clip(np.round(spike_times/dt).astype(int),0,T-1); np.add.at(x,idx,1.0)
    kern,_=gaussian_kernel_continuous(sigma,dt)
    r_hat=np.convolve(x,kern,mode="same")     # already Hz (no /dt)
    return r_hat

def compute_sta(stim, spike_times, dt, window=WIN_STA):
    s=np.asarray(stim,float); T=len(s)
    w_pre,w_post=window
    lags=np.arange(w_pre, w_post+dt/2, dt); L=len(lags)
    acc=np.zeros(L,float); cnt=0
    for t_spk in spike_times:
        i_spk=int(round(t_spk/dt)); i0=i_spk+int(round(w_pre/dt)); i1=i0+L
        if i0<0 or i1>T: continue
        acc+=s[i0:i1]; cnt+=1
    sta=acc/cnt if cnt>0 else np.zeros(L)
    return sta,lags,cnt

def standardize(x): x=np.asarray(x,float); return (x-x.mean())/(x.std()+1e-12)

def sta_to_kernel(sta, lags, dt, tmin, tmax, smooth_ms):
    """取純負lag區段 (tmin<=lag<=tmax<0)，以高斯在lag軸平滑後反轉成因果核"""
    assert tmin < 0 and tmax < 0 and tmin < tmax
    mask=(lags>=tmin)&(lags<=tmax)
    k=sta[mask].copy()
    if smooth_ms and smooth_ms>0:
        from scipy.ndimage import gaussian_filter1d
        sig=max(1,int(round((smooth_ms/1000.0)/dt)))
        k=gaussian_filter1d(k, sigma=sig, mode="nearest")
    D=k[::-1]   # causal τ>=0
    return D

def best_scale_least_squares(y, x_nonneg):
    num=float(np.dot(x_nonneg,y)); den=float(np.dot(x_nonneg,x_nonneg)+1e-12)
    return max(0.0, num/den)

def gen_spikes_advancing_area(r, dt=DT, seed=123):
    rng=_rng(seed); i=0; s=0.0; sp=[]
    r=np.maximum(0.0, np.asarray(r,float))
    while True:
        s+=rng.exponential()
        while i<len(r) and s>r[i]*dt:
            s-=r[i]*dt; i+=1
        if i>=len(r): break
        if r[i]>0: sp.append(i*dt + s/r[i])
        else:
            i+=1
            if i>=len(r): break
    return np.array(sp,float)

# @title
# ------------------ Exercise 1 ------------------
print("Exercise 1: 104 s white-noise; STA window [-0.5, 0.1] s")
simulate_fn = globals().get("simulate_lif_model", simulate_lif_model)
spk1, stim1, t1, dt1 = simulate_fn(duration_s=DUR_EX1, dt=DT, input_current=None, seed=0)
stim1_std = standardize(stim1)
sta, lags, n_used = compute_sta(stim1_std, spk1, dt1, window=WIN_STA)
print(f"Ex1 spikes total = {len(spk1)} ; used in STA = {n_used}")

plt.figure(figsize=(8,4))
plt.plot(lags, sta); plt.axvline(0, ls="--")
plt.title("Exercise 1: Spike-Triggered Average (STA)")
plt.xlabel("Lag (s)"); plt.ylabel("Stimulus (z-scored)")
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex1_sta.png"), dpi=150); plt.show()

# @title
# ------------------ Exercise 2 ------------------
print("\nExercise 2: inputs_alt 10 s + Gaussian σ=0.05 s")
T2=int(round(DUR_EX2/DT))
inputs_alt = globals().get("inputs_alt", None)
if inputs_alt is None or len(np.asarray(inputs_alt).shape)==0:
    inputs_alt = make_colored_stimulus(T2, DT, seed=42, tau=0.050, std=1.0)
else:
    inputs_alt = np.asarray(inputs_alt, float)
    if len(inputs_alt)!=T2:
        inputs_alt = inputs_alt[:T2] if len(inputs_alt)>T2 else np.pad(inputs_alt,(0,T2-len(inputs_alt)))
spk2, stim2, t2, dt2 = simulate_fn(duration_s=DUR_EX2, dt=DT, input_current=inputs_alt, seed=0)
r2_hat = spikes_to_rate_gaussian(spk2, t2, sigma=SIGMA_GAU)

plt.figure(figsize=(10,3.6))
plt.plot(t2, r2_hat)
plt.title("Exercise 2: Gaussian-window Rate Estimate (σ=0.05 s)")
plt.xlabel("Time (s)"); plt.ylabel("Rate (Hz)")
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex2_rate_gaussian.png"), dpi=150); plt.show()

# @title
# ------------------ Exercise 3（自動微調 kernel 視窗與平滑） ------------------
print("\nExercise 3: Auto-tune STA-kernel window & smoothing (negative lags only) + ReLU scaling")

stim2_std = standardize(stim2)

tmin_candidates  = [-0.20, -0.15, -0.12]
tmax_candidates  = [-0.015, -0.012, -0.010, -0.008]
smooth_candidates = [6.0, 8.0, 10.0, 12.0]  # ms

best = {"corr": -1.0, "tmin":None, "tmax":None, "smooth":None, "g":None, "r":None, "X":None, "D":None}
from numpy import corrcoef
for tmin in tmin_candidates:
    for tmax in tmax_candidates:
        if tmin >= tmax: continue
        for sm in smooth_candidates:
            D_kernel = sta_to_kernel(sta, lags, dt2, tmin=tmin, tmax=tmax, smooth_ms=sm)
            if len(D_kernel) < 3: continue
            Lsig = np.convolve(stim2_std, D_kernel, mode="same") * dt2
            X_relu = np.maximum(0.0, Lsig)
            if np.allclose(X_relu.std(), 0.0): continue
            g = best_scale_least_squares(r2_hat, X_relu)
            r_pred = g * X_relu
            c = float(corrcoef(r2_hat, r_pred)[0,1])
            if np.isnan(c): continue
            if c > best["corr"]:
                best.update({"corr":c, "tmin":tmin, "tmax":tmax, "smooth":sm, "g":g, "r":r_pred, "X":X_relu, "D":D_kernel})

# 使用最佳組合
D_kernel = best["D"]; X_relu = best["X"]; r_lnp = best["r"]; g_best = best["g"]
mse  = float(np.mean((r2_hat - r_lnp)**2))
r2   = 1.0 - np.var(r2_hat - r_lnp) / (np.var(r2_hat)+1e-12)
print(f"Best params -> tmin={best['tmin']:.3f}s, tmax={best['tmax']:.3f}s, smooth={best['smooth']:.1f}ms")
print(f"Metrics -> Corr={best['corr']:.3f}, R^2={r2:.3f}, MSE={mse:.3f}, g*={g_best:.4f}")

# 畫 kernel 形狀（可視化一下）
plt.figure(figsize=(7,3))
plt.plot(np.arange(len(D_kernel))*DT*1000, D_kernel)
plt.title("Chosen causal kernel D(τ) (ms domain)")
plt.xlabel("τ (ms)"); plt.ylabel("Amplitude (a.u.)")
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex3_kernel.png"), dpi=150); plt.show()

# 時序比較
plt.figure(figsize=(10,4.2))
plt.plot(t2, r2_hat, label="Rate from Ex2 (Gaussian σ=0.05 s)")
plt.plot(t2, r_lnp,  label="LNP (tuned STA kernel + ReLU*scale)")
plt.title("Exercise 3: Rate Comparison (Target vs LNP) — tuned")
plt.xlabel("Time (s)"); plt.ylabel("Rate (Hz)"); plt.legend()
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex3_rate_compare_tuned.png"), dpi=150); plt.show()

# 散佈圖
plt.figure(figsize=(5,5))
plt.plot(X_relu, r2_hat, ".", ms=2)
plt.title("Exercise 3 (tuned): y=rate(Ex2) vs x=ReLU(Linear conv)")
plt.xlabel("x = ReLU(Linear conv)"); plt.ylabel("y = Gaussian-window rate")
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex3_scatter_tuned.png"), dpi=150); plt.show()

# @title
# ------------------ Exercise 4 ------------------
print("\nExercise 4: Generate 100 spike trains from tuned LNP rate (advancing-area)")
spike_trains = [gen_spikes_advancing_area(r_lnp, dt=DT, seed=1000+k) for k in range(N_RASTER)]

plt.figure(figsize=(10,6))
plt.eventplot(spike_trains, linelengths=0.8)
plt.title("Exercise 4: Raster of 100 Poisson Spike Trains Driven by Tuned LNP Rate")
plt.xlabel("Time (s)"); plt.ylabel("Trial index")
plt.tight_layout(); plt.savefig(os.path.join(OUTDIR,"ex4_raster_tuned.png"), dpi=150); plt.show()